// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package servicesmocks

import (
	"context"
	"text/template"

	"github.com/a-novel-kit/jwt/jwa"
	"github.com/a-novel/service-authentication/internal/dao"
	"github.com/a-novel/service-authentication/internal/services"
	"github.com/a-novel/service-authentication/models"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockConsumeRefreshTokenSource creates a new instance of MockConsumeRefreshTokenSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConsumeRefreshTokenSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConsumeRefreshTokenSource {
	mock := &MockConsumeRefreshTokenSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConsumeRefreshTokenSource is an autogenerated mock type for the ConsumeRefreshTokenSource type
type MockConsumeRefreshTokenSource struct {
	mock.Mock
}

type MockConsumeRefreshTokenSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConsumeRefreshTokenSource) EXPECT() *MockConsumeRefreshTokenSource_Expecter {
	return &MockConsumeRefreshTokenSource_Expecter{mock: &_m.Mock}
}

// IssueToken provides a mock function for the type MockConsumeRefreshTokenSource
func (_mock *MockConsumeRefreshTokenSource) IssueToken(ctx context.Context, request services.IssueTokenRequest) (string, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IssueToken")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) (string, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) string); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.IssueTokenRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockConsumeRefreshTokenSource_IssueToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueToken'
type MockConsumeRefreshTokenSource_IssueToken_Call struct {
	*mock.Call
}

// IssueToken is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockConsumeRefreshTokenSource_Expecter) IssueToken(ctx interface{}, request interface{}) *MockConsumeRefreshTokenSource_IssueToken_Call {
	return &MockConsumeRefreshTokenSource_IssueToken_Call{Call: _e.mock.On("IssueToken", ctx, request)}
}

func (_c *MockConsumeRefreshTokenSource_IssueToken_Call) Run(run func(ctx context.Context, request services.IssueTokenRequest)) *MockConsumeRefreshTokenSource_IssueToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.IssueTokenRequest))
	})
	return _c
}

func (_c *MockConsumeRefreshTokenSource_IssueToken_Call) Return(s string, err error) *MockConsumeRefreshTokenSource_IssueToken_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockConsumeRefreshTokenSource_IssueToken_Call) RunAndReturn(run func(ctx context.Context, request services.IssueTokenRequest) (string, error)) *MockConsumeRefreshTokenSource_IssueToken_Call {
	_c.Call.Return(run)
	return _c
}

// SelectCredentials provides a mock function for the type MockConsumeRefreshTokenSource
func (_mock *MockConsumeRefreshTokenSource) SelectCredentials(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for SelectCredentials")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockConsumeRefreshTokenSource_SelectCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectCredentials'
type MockConsumeRefreshTokenSource_SelectCredentials_Call struct {
	*mock.Call
}

// SelectCredentials is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockConsumeRefreshTokenSource_Expecter) SelectCredentials(ctx interface{}, id interface{}) *MockConsumeRefreshTokenSource_SelectCredentials_Call {
	return &MockConsumeRefreshTokenSource_SelectCredentials_Call{Call: _e.mock.On("SelectCredentials", ctx, id)}
}

func (_c *MockConsumeRefreshTokenSource_SelectCredentials_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockConsumeRefreshTokenSource_SelectCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockConsumeRefreshTokenSource_SelectCredentials_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockConsumeRefreshTokenSource_SelectCredentials_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockConsumeRefreshTokenSource_SelectCredentials_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error)) *MockConsumeRefreshTokenSource_SelectCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockConsumeShortCodeSource creates a new instance of MockConsumeShortCodeSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConsumeShortCodeSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConsumeShortCodeSource {
	mock := &MockConsumeShortCodeSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConsumeShortCodeSource is an autogenerated mock type for the ConsumeShortCodeSource type
type MockConsumeShortCodeSource struct {
	mock.Mock
}

type MockConsumeShortCodeSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConsumeShortCodeSource) EXPECT() *MockConsumeShortCodeSource_Expecter {
	return &MockConsumeShortCodeSource_Expecter{mock: &_m.Mock}
}

// DeleteShortCode provides a mock function for the type MockConsumeShortCodeSource
func (_mock *MockConsumeShortCodeSource) DeleteShortCode(ctx context.Context, data dao.DeleteShortCodeData) (*dao.ShortCodeEntity, error) {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for DeleteShortCode")
	}

	var r0 *dao.ShortCodeEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.DeleteShortCodeData) (*dao.ShortCodeEntity, error)); ok {
		return returnFunc(ctx, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.DeleteShortCodeData) *dao.ShortCodeEntity); ok {
		r0 = returnFunc(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.ShortCodeEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dao.DeleteShortCodeData) error); ok {
		r1 = returnFunc(ctx, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockConsumeShortCodeSource_DeleteShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteShortCode'
type MockConsumeShortCodeSource_DeleteShortCode_Call struct {
	*mock.Call
}

// DeleteShortCode is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *MockConsumeShortCodeSource_Expecter) DeleteShortCode(ctx interface{}, data interface{}) *MockConsumeShortCodeSource_DeleteShortCode_Call {
	return &MockConsumeShortCodeSource_DeleteShortCode_Call{Call: _e.mock.On("DeleteShortCode", ctx, data)}
}

func (_c *MockConsumeShortCodeSource_DeleteShortCode_Call) Run(run func(ctx context.Context, data dao.DeleteShortCodeData)) *MockConsumeShortCodeSource_DeleteShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(dao.DeleteShortCodeData))
	})
	return _c
}

func (_c *MockConsumeShortCodeSource_DeleteShortCode_Call) Return(shortCodeEntity *dao.ShortCodeEntity, err error) *MockConsumeShortCodeSource_DeleteShortCode_Call {
	_c.Call.Return(shortCodeEntity, err)
	return _c
}

func (_c *MockConsumeShortCodeSource_DeleteShortCode_Call) RunAndReturn(run func(ctx context.Context, data dao.DeleteShortCodeData) (*dao.ShortCodeEntity, error)) *MockConsumeShortCodeSource_DeleteShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// SelectShortCodeByParams provides a mock function for the type MockConsumeShortCodeSource
func (_mock *MockConsumeShortCodeSource) SelectShortCodeByParams(ctx context.Context, data dao.SelectShortCodeByParamsData) (*dao.ShortCodeEntity, error) {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for SelectShortCodeByParams")
	}

	var r0 *dao.ShortCodeEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.SelectShortCodeByParamsData) (*dao.ShortCodeEntity, error)); ok {
		return returnFunc(ctx, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.SelectShortCodeByParamsData) *dao.ShortCodeEntity); ok {
		r0 = returnFunc(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.ShortCodeEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dao.SelectShortCodeByParamsData) error); ok {
		r1 = returnFunc(ctx, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockConsumeShortCodeSource_SelectShortCodeByParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectShortCodeByParams'
type MockConsumeShortCodeSource_SelectShortCodeByParams_Call struct {
	*mock.Call
}

// SelectShortCodeByParams is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *MockConsumeShortCodeSource_Expecter) SelectShortCodeByParams(ctx interface{}, data interface{}) *MockConsumeShortCodeSource_SelectShortCodeByParams_Call {
	return &MockConsumeShortCodeSource_SelectShortCodeByParams_Call{Call: _e.mock.On("SelectShortCodeByParams", ctx, data)}
}

func (_c *MockConsumeShortCodeSource_SelectShortCodeByParams_Call) Run(run func(ctx context.Context, data dao.SelectShortCodeByParamsData)) *MockConsumeShortCodeSource_SelectShortCodeByParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(dao.SelectShortCodeByParamsData))
	})
	return _c
}

func (_c *MockConsumeShortCodeSource_SelectShortCodeByParams_Call) Return(shortCodeEntity *dao.ShortCodeEntity, err error) *MockConsumeShortCodeSource_SelectShortCodeByParams_Call {
	_c.Call.Return(shortCodeEntity, err)
	return _c
}

func (_c *MockConsumeShortCodeSource_SelectShortCodeByParams_Call) RunAndReturn(run func(ctx context.Context, data dao.SelectShortCodeByParamsData) (*dao.ShortCodeEntity, error)) *MockConsumeShortCodeSource_SelectShortCodeByParams_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCreateShortCodeSource creates a new instance of MockCreateShortCodeSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCreateShortCodeSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCreateShortCodeSource {
	mock := &MockCreateShortCodeSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCreateShortCodeSource is an autogenerated mock type for the CreateShortCodeSource type
type MockCreateShortCodeSource struct {
	mock.Mock
}

type MockCreateShortCodeSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCreateShortCodeSource) EXPECT() *MockCreateShortCodeSource_Expecter {
	return &MockCreateShortCodeSource_Expecter{mock: &_m.Mock}
}

// InsertShortCode provides a mock function for the type MockCreateShortCodeSource
func (_mock *MockCreateShortCodeSource) InsertShortCode(ctx context.Context, data dao.InsertShortCodeData) (*dao.ShortCodeEntity, error) {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for InsertShortCode")
	}

	var r0 *dao.ShortCodeEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.InsertShortCodeData) (*dao.ShortCodeEntity, error)); ok {
		return returnFunc(ctx, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.InsertShortCodeData) *dao.ShortCodeEntity); ok {
		r0 = returnFunc(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.ShortCodeEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dao.InsertShortCodeData) error); ok {
		r1 = returnFunc(ctx, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCreateShortCodeSource_InsertShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertShortCode'
type MockCreateShortCodeSource_InsertShortCode_Call struct {
	*mock.Call
}

// InsertShortCode is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *MockCreateShortCodeSource_Expecter) InsertShortCode(ctx interface{}, data interface{}) *MockCreateShortCodeSource_InsertShortCode_Call {
	return &MockCreateShortCodeSource_InsertShortCode_Call{Call: _e.mock.On("InsertShortCode", ctx, data)}
}

func (_c *MockCreateShortCodeSource_InsertShortCode_Call) Run(run func(ctx context.Context, data dao.InsertShortCodeData)) *MockCreateShortCodeSource_InsertShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(dao.InsertShortCodeData))
	})
	return _c
}

func (_c *MockCreateShortCodeSource_InsertShortCode_Call) Return(shortCodeEntity *dao.ShortCodeEntity, err error) *MockCreateShortCodeSource_InsertShortCode_Call {
	_c.Call.Return(shortCodeEntity, err)
	return _c
}

func (_c *MockCreateShortCodeSource_InsertShortCode_Call) RunAndReturn(run func(ctx context.Context, data dao.InsertShortCodeData) (*dao.ShortCodeEntity, error)) *MockCreateShortCodeSource_InsertShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEmailExistsSource creates a new instance of MockEmailExistsSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEmailExistsSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEmailExistsSource {
	mock := &MockEmailExistsSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEmailExistsSource is an autogenerated mock type for the EmailExistsSource type
type MockEmailExistsSource struct {
	mock.Mock
}

type MockEmailExistsSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEmailExistsSource) EXPECT() *MockEmailExistsSource_Expecter {
	return &MockEmailExistsSource_Expecter{mock: &_m.Mock}
}

// ExistsCredentialsEmail provides a mock function for the type MockEmailExistsSource
func (_mock *MockEmailExistsSource) ExistsCredentialsEmail(ctx context.Context, email string) (bool, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for ExistsCredentialsEmail")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = returnFunc(ctx, email)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEmailExistsSource_ExistsCredentialsEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsCredentialsEmail'
type MockEmailExistsSource_ExistsCredentialsEmail_Call struct {
	*mock.Call
}

// ExistsCredentialsEmail is a helper method to define mock.On call
//   - ctx
//   - email
func (_e *MockEmailExistsSource_Expecter) ExistsCredentialsEmail(ctx interface{}, email interface{}) *MockEmailExistsSource_ExistsCredentialsEmail_Call {
	return &MockEmailExistsSource_ExistsCredentialsEmail_Call{Call: _e.mock.On("ExistsCredentialsEmail", ctx, email)}
}

func (_c *MockEmailExistsSource_ExistsCredentialsEmail_Call) Run(run func(ctx context.Context, email string)) *MockEmailExistsSource_ExistsCredentialsEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockEmailExistsSource_ExistsCredentialsEmail_Call) Return(b bool, err error) *MockEmailExistsSource_ExistsCredentialsEmail_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockEmailExistsSource_ExistsCredentialsEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (bool, error)) *MockEmailExistsSource_ExistsCredentialsEmail_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGenerateKeySource creates a new instance of MockGenerateKeySource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGenerateKeySource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGenerateKeySource {
	mock := &MockGenerateKeySource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockGenerateKeySource is an autogenerated mock type for the GenerateKeySource type
type MockGenerateKeySource struct {
	mock.Mock
}

type MockGenerateKeySource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGenerateKeySource) EXPECT() *MockGenerateKeySource_Expecter {
	return &MockGenerateKeySource_Expecter{mock: &_m.Mock}
}

// InsertKey provides a mock function for the type MockGenerateKeySource
func (_mock *MockGenerateKeySource) InsertKey(ctx context.Context, data dao.InsertKeyData) (*dao.KeyEntity, error) {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for InsertKey")
	}

	var r0 *dao.KeyEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.InsertKeyData) (*dao.KeyEntity, error)); ok {
		return returnFunc(ctx, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.InsertKeyData) *dao.KeyEntity); ok {
		r0 = returnFunc(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.KeyEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dao.InsertKeyData) error); ok {
		r1 = returnFunc(ctx, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGenerateKeySource_InsertKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertKey'
type MockGenerateKeySource_InsertKey_Call struct {
	*mock.Call
}

// InsertKey is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *MockGenerateKeySource_Expecter) InsertKey(ctx interface{}, data interface{}) *MockGenerateKeySource_InsertKey_Call {
	return &MockGenerateKeySource_InsertKey_Call{Call: _e.mock.On("InsertKey", ctx, data)}
}

func (_c *MockGenerateKeySource_InsertKey_Call) Run(run func(ctx context.Context, data dao.InsertKeyData)) *MockGenerateKeySource_InsertKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(dao.InsertKeyData))
	})
	return _c
}

func (_c *MockGenerateKeySource_InsertKey_Call) Return(keyEntity *dao.KeyEntity, err error) *MockGenerateKeySource_InsertKey_Call {
	_c.Call.Return(keyEntity, err)
	return _c
}

func (_c *MockGenerateKeySource_InsertKey_Call) RunAndReturn(run func(ctx context.Context, data dao.InsertKeyData) (*dao.KeyEntity, error)) *MockGenerateKeySource_InsertKey_Call {
	_c.Call.Return(run)
	return _c
}

// SearchKeys provides a mock function for the type MockGenerateKeySource
func (_mock *MockGenerateKeySource) SearchKeys(ctx context.Context, usage models.KeyUsage) ([]*dao.KeyEntity, error) {
	ret := _mock.Called(ctx, usage)

	if len(ret) == 0 {
		panic("no return value specified for SearchKeys")
	}

	var r0 []*dao.KeyEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.KeyUsage) ([]*dao.KeyEntity, error)); ok {
		return returnFunc(ctx, usage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.KeyUsage) []*dao.KeyEntity); ok {
		r0 = returnFunc(ctx, usage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.KeyEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.KeyUsage) error); ok {
		r1 = returnFunc(ctx, usage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockGenerateKeySource_SearchKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchKeys'
type MockGenerateKeySource_SearchKeys_Call struct {
	*mock.Call
}

// SearchKeys is a helper method to define mock.On call
//   - ctx
//   - usage
func (_e *MockGenerateKeySource_Expecter) SearchKeys(ctx interface{}, usage interface{}) *MockGenerateKeySource_SearchKeys_Call {
	return &MockGenerateKeySource_SearchKeys_Call{Call: _e.mock.On("SearchKeys", ctx, usage)}
}

func (_c *MockGenerateKeySource_SearchKeys_Call) Run(run func(ctx context.Context, usage models.KeyUsage)) *MockGenerateKeySource_SearchKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.KeyUsage))
	})
	return _c
}

func (_c *MockGenerateKeySource_SearchKeys_Call) Return(keyEntitys []*dao.KeyEntity, err error) *MockGenerateKeySource_SearchKeys_Call {
	_c.Call.Return(keyEntitys, err)
	return _c
}

func (_c *MockGenerateKeySource_SearchKeys_Call) RunAndReturn(run func(ctx context.Context, usage models.KeyUsage) ([]*dao.KeyEntity, error)) *MockGenerateKeySource_SearchKeys_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockKeysProviderSource creates a new instance of MockKeysProviderSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockKeysProviderSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockKeysProviderSource {
	mock := &MockKeysProviderSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockKeysProviderSource is an autogenerated mock type for the KeysProviderSource type
type MockKeysProviderSource struct {
	mock.Mock
}

type MockKeysProviderSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockKeysProviderSource) EXPECT() *MockKeysProviderSource_Expecter {
	return &MockKeysProviderSource_Expecter{mock: &_m.Mock}
}

// SearchKeys provides a mock function for the type MockKeysProviderSource
func (_mock *MockKeysProviderSource) SearchKeys(ctx context.Context, request services.SearchKeysRequest) ([]*jwa.JWK, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for SearchKeys")
	}

	var r0 []*jwa.JWK
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.SearchKeysRequest) ([]*jwa.JWK, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.SearchKeysRequest) []*jwa.JWK); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*jwa.JWK)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.SearchKeysRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockKeysProviderSource_SearchKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchKeys'
type MockKeysProviderSource_SearchKeys_Call struct {
	*mock.Call
}

// SearchKeys is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockKeysProviderSource_Expecter) SearchKeys(ctx interface{}, request interface{}) *MockKeysProviderSource_SearchKeys_Call {
	return &MockKeysProviderSource_SearchKeys_Call{Call: _e.mock.On("SearchKeys", ctx, request)}
}

func (_c *MockKeysProviderSource_SearchKeys_Call) Run(run func(ctx context.Context, request services.SearchKeysRequest)) *MockKeysProviderSource_SearchKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.SearchKeysRequest))
	})
	return _c
}

func (_c *MockKeysProviderSource_SearchKeys_Call) Return(jWKs []*jwa.JWK, err error) *MockKeysProviderSource_SearchKeys_Call {
	_c.Call.Return(jWKs, err)
	return _c
}

func (_c *MockKeysProviderSource_SearchKeys_Call) RunAndReturn(run func(ctx context.Context, request services.SearchKeysRequest) ([]*jwa.JWK, error)) *MockKeysProviderSource_SearchKeys_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockListUsersSource creates a new instance of MockListUsersSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockListUsersSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockListUsersSource {
	mock := &MockListUsersSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockListUsersSource is an autogenerated mock type for the ListUsersSource type
type MockListUsersSource struct {
	mock.Mock
}

type MockListUsersSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockListUsersSource) EXPECT() *MockListUsersSource_Expecter {
	return &MockListUsersSource_Expecter{mock: &_m.Mock}
}

// ListUsers provides a mock function for the type MockListUsersSource
func (_mock *MockListUsersSource) ListUsers(ctx context.Context, data dao.ListUsersData) ([]*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []*dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.ListUsersData) ([]*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.ListUsersData) []*dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dao.ListUsersData) error); ok {
		r1 = returnFunc(ctx, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockListUsersSource_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type MockListUsersSource_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *MockListUsersSource_Expecter) ListUsers(ctx interface{}, data interface{}) *MockListUsersSource_ListUsers_Call {
	return &MockListUsersSource_ListUsers_Call{Call: _e.mock.On("ListUsers", ctx, data)}
}

func (_c *MockListUsersSource_ListUsers_Call) Run(run func(ctx context.Context, data dao.ListUsersData)) *MockListUsersSource_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(dao.ListUsersData))
	})
	return _c
}

func (_c *MockListUsersSource_ListUsers_Call) Return(credentialsEntitys []*dao.CredentialsEntity, err error) *MockListUsersSource_ListUsers_Call {
	_c.Call.Return(credentialsEntitys, err)
	return _c
}

func (_c *MockListUsersSource_ListUsers_Call) RunAndReturn(run func(ctx context.Context, data dao.ListUsersData) ([]*dao.CredentialsEntity, error)) *MockListUsersSource_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLoginSource creates a new instance of MockLoginSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLoginSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLoginSource {
	mock := &MockLoginSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLoginSource is an autogenerated mock type for the LoginSource type
type MockLoginSource struct {
	mock.Mock
}

type MockLoginSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLoginSource) EXPECT() *MockLoginSource_Expecter {
	return &MockLoginSource_Expecter{mock: &_m.Mock}
}

// IssueRefreshToken provides a mock function for the type MockLoginSource
func (_mock *MockLoginSource) IssueRefreshToken(ctx context.Context, request services.IssueRefreshTokenRequest) (string, *jwa.Claims, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IssueRefreshToken")
	}

	var r0 string
	var r1 *jwa.Claims
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueRefreshTokenRequest) (string, *jwa.Claims, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueRefreshTokenRequest) string); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.IssueRefreshTokenRequest) *jwa.Claims); ok {
		r1 = returnFunc(ctx, request)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*jwa.Claims)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, services.IssueRefreshTokenRequest) error); ok {
		r2 = returnFunc(ctx, request)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockLoginSource_IssueRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueRefreshToken'
type MockLoginSource_IssueRefreshToken_Call struct {
	*mock.Call
}

// IssueRefreshToken is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockLoginSource_Expecter) IssueRefreshToken(ctx interface{}, request interface{}) *MockLoginSource_IssueRefreshToken_Call {
	return &MockLoginSource_IssueRefreshToken_Call{Call: _e.mock.On("IssueRefreshToken", ctx, request)}
}

func (_c *MockLoginSource_IssueRefreshToken_Call) Run(run func(ctx context.Context, request services.IssueRefreshTokenRequest)) *MockLoginSource_IssueRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.IssueRefreshTokenRequest))
	})
	return _c
}

func (_c *MockLoginSource_IssueRefreshToken_Call) Return(s string, claims *jwa.Claims, err error) *MockLoginSource_IssueRefreshToken_Call {
	_c.Call.Return(s, claims, err)
	return _c
}

func (_c *MockLoginSource_IssueRefreshToken_Call) RunAndReturn(run func(ctx context.Context, request services.IssueRefreshTokenRequest) (string, *jwa.Claims, error)) *MockLoginSource_IssueRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// IssueToken provides a mock function for the type MockLoginSource
func (_mock *MockLoginSource) IssueToken(ctx context.Context, request services.IssueTokenRequest) (string, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IssueToken")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) (string, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) string); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.IssueTokenRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLoginSource_IssueToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueToken'
type MockLoginSource_IssueToken_Call struct {
	*mock.Call
}

// IssueToken is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockLoginSource_Expecter) IssueToken(ctx interface{}, request interface{}) *MockLoginSource_IssueToken_Call {
	return &MockLoginSource_IssueToken_Call{Call: _e.mock.On("IssueToken", ctx, request)}
}

func (_c *MockLoginSource_IssueToken_Call) Run(run func(ctx context.Context, request services.IssueTokenRequest)) *MockLoginSource_IssueToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.IssueTokenRequest))
	})
	return _c
}

func (_c *MockLoginSource_IssueToken_Call) Return(s string, err error) *MockLoginSource_IssueToken_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLoginSource_IssueToken_Call) RunAndReturn(run func(ctx context.Context, request services.IssueTokenRequest) (string, error)) *MockLoginSource_IssueToken_Call {
	_c.Call.Return(run)
	return _c
}

// SelectCredentialsByEmail provides a mock function for the type MockLoginSource
func (_mock *MockLoginSource) SelectCredentialsByEmail(ctx context.Context, email string) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for SelectCredentialsByEmail")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLoginSource_SelectCredentialsByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectCredentialsByEmail'
type MockLoginSource_SelectCredentialsByEmail_Call struct {
	*mock.Call
}

// SelectCredentialsByEmail is a helper method to define mock.On call
//   - ctx
//   - email
func (_e *MockLoginSource_Expecter) SelectCredentialsByEmail(ctx interface{}, email interface{}) *MockLoginSource_SelectCredentialsByEmail_Call {
	return &MockLoginSource_SelectCredentialsByEmail_Call{Call: _e.mock.On("SelectCredentialsByEmail", ctx, email)}
}

func (_c *MockLoginSource_SelectCredentialsByEmail_Call) Run(run func(ctx context.Context, email string)) *MockLoginSource_SelectCredentialsByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLoginSource_SelectCredentialsByEmail_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockLoginSource_SelectCredentialsByEmail_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockLoginSource_SelectCredentialsByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*dao.CredentialsEntity, error)) *MockLoginSource_SelectCredentialsByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLoginAnonSource creates a new instance of MockLoginAnonSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLoginAnonSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLoginAnonSource {
	mock := &MockLoginAnonSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLoginAnonSource is an autogenerated mock type for the LoginAnonSource type
type MockLoginAnonSource struct {
	mock.Mock
}

type MockLoginAnonSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLoginAnonSource) EXPECT() *MockLoginAnonSource_Expecter {
	return &MockLoginAnonSource_Expecter{mock: &_m.Mock}
}

// IssueToken provides a mock function for the type MockLoginAnonSource
func (_mock *MockLoginAnonSource) IssueToken(ctx context.Context, request services.IssueTokenRequest) (string, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IssueToken")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) (string, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) string); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.IssueTokenRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLoginAnonSource_IssueToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueToken'
type MockLoginAnonSource_IssueToken_Call struct {
	*mock.Call
}

// IssueToken is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockLoginAnonSource_Expecter) IssueToken(ctx interface{}, request interface{}) *MockLoginAnonSource_IssueToken_Call {
	return &MockLoginAnonSource_IssueToken_Call{Call: _e.mock.On("IssueToken", ctx, request)}
}

func (_c *MockLoginAnonSource_IssueToken_Call) Run(run func(ctx context.Context, request services.IssueTokenRequest)) *MockLoginAnonSource_IssueToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.IssueTokenRequest))
	})
	return _c
}

func (_c *MockLoginAnonSource_IssueToken_Call) Return(s string, err error) *MockLoginAnonSource_IssueToken_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLoginAnonSource_IssueToken_Call) RunAndReturn(run func(ctx context.Context, request services.IssueTokenRequest) (string, error)) *MockLoginAnonSource_IssueToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRegisterSource creates a new instance of MockRegisterSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRegisterSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRegisterSource {
	mock := &MockRegisterSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRegisterSource is an autogenerated mock type for the RegisterSource type
type MockRegisterSource struct {
	mock.Mock
}

type MockRegisterSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRegisterSource) EXPECT() *MockRegisterSource_Expecter {
	return &MockRegisterSource_Expecter{mock: &_m.Mock}
}

// ConsumeShortCode provides a mock function for the type MockRegisterSource
func (_mock *MockRegisterSource) ConsumeShortCode(ctx context.Context, request services.ConsumeShortCodeRequest) (*models.ShortCode, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeShortCode")
	}

	var r0 *models.ShortCode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.ConsumeShortCodeRequest) (*models.ShortCode, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.ConsumeShortCodeRequest) *models.ShortCode); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ShortCode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.ConsumeShortCodeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRegisterSource_ConsumeShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumeShortCode'
type MockRegisterSource_ConsumeShortCode_Call struct {
	*mock.Call
}

// ConsumeShortCode is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockRegisterSource_Expecter) ConsumeShortCode(ctx interface{}, request interface{}) *MockRegisterSource_ConsumeShortCode_Call {
	return &MockRegisterSource_ConsumeShortCode_Call{Call: _e.mock.On("ConsumeShortCode", ctx, request)}
}

func (_c *MockRegisterSource_ConsumeShortCode_Call) Run(run func(ctx context.Context, request services.ConsumeShortCodeRequest)) *MockRegisterSource_ConsumeShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.ConsumeShortCodeRequest))
	})
	return _c
}

func (_c *MockRegisterSource_ConsumeShortCode_Call) Return(shortCode *models.ShortCode, err error) *MockRegisterSource_ConsumeShortCode_Call {
	_c.Call.Return(shortCode, err)
	return _c
}

func (_c *MockRegisterSource_ConsumeShortCode_Call) RunAndReturn(run func(ctx context.Context, request services.ConsumeShortCodeRequest) (*models.ShortCode, error)) *MockRegisterSource_ConsumeShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// InsertCredentials provides a mock function for the type MockRegisterSource
func (_mock *MockRegisterSource) InsertCredentials(ctx context.Context, data dao.InsertCredentialsData) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for InsertCredentials")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.InsertCredentialsData) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, dao.InsertCredentialsData) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, dao.InsertCredentialsData) error); ok {
		r1 = returnFunc(ctx, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRegisterSource_InsertCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertCredentials'
type MockRegisterSource_InsertCredentials_Call struct {
	*mock.Call
}

// InsertCredentials is a helper method to define mock.On call
//   - ctx
//   - data
func (_e *MockRegisterSource_Expecter) InsertCredentials(ctx interface{}, data interface{}) *MockRegisterSource_InsertCredentials_Call {
	return &MockRegisterSource_InsertCredentials_Call{Call: _e.mock.On("InsertCredentials", ctx, data)}
}

func (_c *MockRegisterSource_InsertCredentials_Call) Run(run func(ctx context.Context, data dao.InsertCredentialsData)) *MockRegisterSource_InsertCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(dao.InsertCredentialsData))
	})
	return _c
}

func (_c *MockRegisterSource_InsertCredentials_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockRegisterSource_InsertCredentials_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockRegisterSource_InsertCredentials_Call) RunAndReturn(run func(ctx context.Context, data dao.InsertCredentialsData) (*dao.CredentialsEntity, error)) *MockRegisterSource_InsertCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// IssueRefreshToken provides a mock function for the type MockRegisterSource
func (_mock *MockRegisterSource) IssueRefreshToken(ctx context.Context, request services.IssueRefreshTokenRequest) (string, *jwa.Claims, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IssueRefreshToken")
	}

	var r0 string
	var r1 *jwa.Claims
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueRefreshTokenRequest) (string, *jwa.Claims, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueRefreshTokenRequest) string); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.IssueRefreshTokenRequest) *jwa.Claims); ok {
		r1 = returnFunc(ctx, request)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*jwa.Claims)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, services.IssueRefreshTokenRequest) error); ok {
		r2 = returnFunc(ctx, request)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockRegisterSource_IssueRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueRefreshToken'
type MockRegisterSource_IssueRefreshToken_Call struct {
	*mock.Call
}

// IssueRefreshToken is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockRegisterSource_Expecter) IssueRefreshToken(ctx interface{}, request interface{}) *MockRegisterSource_IssueRefreshToken_Call {
	return &MockRegisterSource_IssueRefreshToken_Call{Call: _e.mock.On("IssueRefreshToken", ctx, request)}
}

func (_c *MockRegisterSource_IssueRefreshToken_Call) Run(run func(ctx context.Context, request services.IssueRefreshTokenRequest)) *MockRegisterSource_IssueRefreshToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.IssueRefreshTokenRequest))
	})
	return _c
}

func (_c *MockRegisterSource_IssueRefreshToken_Call) Return(s string, claims *jwa.Claims, err error) *MockRegisterSource_IssueRefreshToken_Call {
	_c.Call.Return(s, claims, err)
	return _c
}

func (_c *MockRegisterSource_IssueRefreshToken_Call) RunAndReturn(run func(ctx context.Context, request services.IssueRefreshTokenRequest) (string, *jwa.Claims, error)) *MockRegisterSource_IssueRefreshToken_Call {
	_c.Call.Return(run)
	return _c
}

// IssueToken provides a mock function for the type MockRegisterSource
func (_mock *MockRegisterSource) IssueToken(ctx context.Context, request services.IssueTokenRequest) (string, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for IssueToken")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) (string, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.IssueTokenRequest) string); ok {
		r0 = returnFunc(ctx, request)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.IssueTokenRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRegisterSource_IssueToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssueToken'
type MockRegisterSource_IssueToken_Call struct {
	*mock.Call
}

// IssueToken is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockRegisterSource_Expecter) IssueToken(ctx interface{}, request interface{}) *MockRegisterSource_IssueToken_Call {
	return &MockRegisterSource_IssueToken_Call{Call: _e.mock.On("IssueToken", ctx, request)}
}

func (_c *MockRegisterSource_IssueToken_Call) Run(run func(ctx context.Context, request services.IssueTokenRequest)) *MockRegisterSource_IssueToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.IssueTokenRequest))
	})
	return _c
}

func (_c *MockRegisterSource_IssueToken_Call) Return(s string, err error) *MockRegisterSource_IssueToken_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockRegisterSource_IssueToken_Call) RunAndReturn(run func(ctx context.Context, request services.IssueTokenRequest) (string, error)) *MockRegisterSource_IssueToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRequestEmailUpdateSource creates a new instance of MockRequestEmailUpdateSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRequestEmailUpdateSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRequestEmailUpdateSource {
	mock := &MockRequestEmailUpdateSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRequestEmailUpdateSource is an autogenerated mock type for the RequestEmailUpdateSource type
type MockRequestEmailUpdateSource struct {
	mock.Mock
}

type MockRequestEmailUpdateSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRequestEmailUpdateSource) EXPECT() *MockRequestEmailUpdateSource_Expecter {
	return &MockRequestEmailUpdateSource_Expecter{mock: &_m.Mock}
}

// CreateShortCode provides a mock function for the type MockRequestEmailUpdateSource
func (_mock *MockRequestEmailUpdateSource) CreateShortCode(ctx context.Context, request services.CreateShortCodeRequest) (*models.ShortCode, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateShortCode")
	}

	var r0 *models.ShortCode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.CreateShortCodeRequest) (*models.ShortCode, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.CreateShortCodeRequest) *models.ShortCode); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ShortCode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.CreateShortCodeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRequestEmailUpdateSource_CreateShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateShortCode'
type MockRequestEmailUpdateSource_CreateShortCode_Call struct {
	*mock.Call
}

// CreateShortCode is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockRequestEmailUpdateSource_Expecter) CreateShortCode(ctx interface{}, request interface{}) *MockRequestEmailUpdateSource_CreateShortCode_Call {
	return &MockRequestEmailUpdateSource_CreateShortCode_Call{Call: _e.mock.On("CreateShortCode", ctx, request)}
}

func (_c *MockRequestEmailUpdateSource_CreateShortCode_Call) Run(run func(ctx context.Context, request services.CreateShortCodeRequest)) *MockRequestEmailUpdateSource_CreateShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.CreateShortCodeRequest))
	})
	return _c
}

func (_c *MockRequestEmailUpdateSource_CreateShortCode_Call) Return(shortCode *models.ShortCode, err error) *MockRequestEmailUpdateSource_CreateShortCode_Call {
	_c.Call.Return(shortCode, err)
	return _c
}

func (_c *MockRequestEmailUpdateSource_CreateShortCode_Call) RunAndReturn(run func(ctx context.Context, request services.CreateShortCodeRequest) (*models.ShortCode, error)) *MockRequestEmailUpdateSource_CreateShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// SMTP provides a mock function for the type MockRequestEmailUpdateSource
func (_mock *MockRequestEmailUpdateSource) SMTP(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any) {
	_mock.Called(ctx, message, lang, tos, data)
	return
}

// MockRequestEmailUpdateSource_SMTP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMTP'
type MockRequestEmailUpdateSource_SMTP_Call struct {
	*mock.Call
}

// SMTP is a helper method to define mock.On call
//   - ctx
//   - message
//   - lang
//   - tos
//   - data
func (_e *MockRequestEmailUpdateSource_Expecter) SMTP(ctx interface{}, message interface{}, lang interface{}, tos interface{}, data interface{}) *MockRequestEmailUpdateSource_SMTP_Call {
	return &MockRequestEmailUpdateSource_SMTP_Call{Call: _e.mock.On("SMTP", ctx, message, lang, tos, data)}
}

func (_c *MockRequestEmailUpdateSource_SMTP_Call) Run(run func(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any)) *MockRequestEmailUpdateSource_SMTP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*template.Template), args[2].(models.Lang), args[3].([]string), args[4].(any))
	})
	return _c
}

func (_c *MockRequestEmailUpdateSource_SMTP_Call) Return() *MockRequestEmailUpdateSource_SMTP_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockRequestEmailUpdateSource_SMTP_Call) RunAndReturn(run func(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any)) *MockRequestEmailUpdateSource_SMTP_Call {
	_c.Run(run)
	return _c
}

// NewMockRequestPasswordResetSource creates a new instance of MockRequestPasswordResetSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRequestPasswordResetSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRequestPasswordResetSource {
	mock := &MockRequestPasswordResetSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRequestPasswordResetSource is an autogenerated mock type for the RequestPasswordResetSource type
type MockRequestPasswordResetSource struct {
	mock.Mock
}

type MockRequestPasswordResetSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRequestPasswordResetSource) EXPECT() *MockRequestPasswordResetSource_Expecter {
	return &MockRequestPasswordResetSource_Expecter{mock: &_m.Mock}
}

// CreateShortCode provides a mock function for the type MockRequestPasswordResetSource
func (_mock *MockRequestPasswordResetSource) CreateShortCode(ctx context.Context, request services.CreateShortCodeRequest) (*models.ShortCode, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateShortCode")
	}

	var r0 *models.ShortCode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.CreateShortCodeRequest) (*models.ShortCode, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.CreateShortCodeRequest) *models.ShortCode); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ShortCode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.CreateShortCodeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRequestPasswordResetSource_CreateShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateShortCode'
type MockRequestPasswordResetSource_CreateShortCode_Call struct {
	*mock.Call
}

// CreateShortCode is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockRequestPasswordResetSource_Expecter) CreateShortCode(ctx interface{}, request interface{}) *MockRequestPasswordResetSource_CreateShortCode_Call {
	return &MockRequestPasswordResetSource_CreateShortCode_Call{Call: _e.mock.On("CreateShortCode", ctx, request)}
}

func (_c *MockRequestPasswordResetSource_CreateShortCode_Call) Run(run func(ctx context.Context, request services.CreateShortCodeRequest)) *MockRequestPasswordResetSource_CreateShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.CreateShortCodeRequest))
	})
	return _c
}

func (_c *MockRequestPasswordResetSource_CreateShortCode_Call) Return(shortCode *models.ShortCode, err error) *MockRequestPasswordResetSource_CreateShortCode_Call {
	_c.Call.Return(shortCode, err)
	return _c
}

func (_c *MockRequestPasswordResetSource_CreateShortCode_Call) RunAndReturn(run func(ctx context.Context, request services.CreateShortCodeRequest) (*models.ShortCode, error)) *MockRequestPasswordResetSource_CreateShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// SMTP provides a mock function for the type MockRequestPasswordResetSource
func (_mock *MockRequestPasswordResetSource) SMTP(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any) {
	_mock.Called(ctx, message, lang, tos, data)
	return
}

// MockRequestPasswordResetSource_SMTP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMTP'
type MockRequestPasswordResetSource_SMTP_Call struct {
	*mock.Call
}

// SMTP is a helper method to define mock.On call
//   - ctx
//   - message
//   - lang
//   - tos
//   - data
func (_e *MockRequestPasswordResetSource_Expecter) SMTP(ctx interface{}, message interface{}, lang interface{}, tos interface{}, data interface{}) *MockRequestPasswordResetSource_SMTP_Call {
	return &MockRequestPasswordResetSource_SMTP_Call{Call: _e.mock.On("SMTP", ctx, message, lang, tos, data)}
}

func (_c *MockRequestPasswordResetSource_SMTP_Call) Run(run func(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any)) *MockRequestPasswordResetSource_SMTP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*template.Template), args[2].(models.Lang), args[3].([]string), args[4].(any))
	})
	return _c
}

func (_c *MockRequestPasswordResetSource_SMTP_Call) Return() *MockRequestPasswordResetSource_SMTP_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockRequestPasswordResetSource_SMTP_Call) RunAndReturn(run func(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any)) *MockRequestPasswordResetSource_SMTP_Call {
	_c.Run(run)
	return _c
}

// SelectCredentialsByEmail provides a mock function for the type MockRequestPasswordResetSource
func (_mock *MockRequestPasswordResetSource) SelectCredentialsByEmail(ctx context.Context, email string) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for SelectCredentialsByEmail")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRequestPasswordResetSource_SelectCredentialsByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectCredentialsByEmail'
type MockRequestPasswordResetSource_SelectCredentialsByEmail_Call struct {
	*mock.Call
}

// SelectCredentialsByEmail is a helper method to define mock.On call
//   - ctx
//   - email
func (_e *MockRequestPasswordResetSource_Expecter) SelectCredentialsByEmail(ctx interface{}, email interface{}) *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call {
	return &MockRequestPasswordResetSource_SelectCredentialsByEmail_Call{Call: _e.mock.On("SelectCredentialsByEmail", ctx, email)}
}

func (_c *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call) Run(run func(ctx context.Context, email string)) *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*dao.CredentialsEntity, error)) *MockRequestPasswordResetSource_SelectCredentialsByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRequestRegisterSource creates a new instance of MockRequestRegisterSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRequestRegisterSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRequestRegisterSource {
	mock := &MockRequestRegisterSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRequestRegisterSource is an autogenerated mock type for the RequestRegisterSource type
type MockRequestRegisterSource struct {
	mock.Mock
}

type MockRequestRegisterSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRequestRegisterSource) EXPECT() *MockRequestRegisterSource_Expecter {
	return &MockRequestRegisterSource_Expecter{mock: &_m.Mock}
}

// CreateShortCode provides a mock function for the type MockRequestRegisterSource
func (_mock *MockRequestRegisterSource) CreateShortCode(ctx context.Context, request services.CreateShortCodeRequest) (*models.ShortCode, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateShortCode")
	}

	var r0 *models.ShortCode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.CreateShortCodeRequest) (*models.ShortCode, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.CreateShortCodeRequest) *models.ShortCode); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ShortCode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.CreateShortCodeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRequestRegisterSource_CreateShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateShortCode'
type MockRequestRegisterSource_CreateShortCode_Call struct {
	*mock.Call
}

// CreateShortCode is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockRequestRegisterSource_Expecter) CreateShortCode(ctx interface{}, request interface{}) *MockRequestRegisterSource_CreateShortCode_Call {
	return &MockRequestRegisterSource_CreateShortCode_Call{Call: _e.mock.On("CreateShortCode", ctx, request)}
}

func (_c *MockRequestRegisterSource_CreateShortCode_Call) Run(run func(ctx context.Context, request services.CreateShortCodeRequest)) *MockRequestRegisterSource_CreateShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.CreateShortCodeRequest))
	})
	return _c
}

func (_c *MockRequestRegisterSource_CreateShortCode_Call) Return(shortCode *models.ShortCode, err error) *MockRequestRegisterSource_CreateShortCode_Call {
	_c.Call.Return(shortCode, err)
	return _c
}

func (_c *MockRequestRegisterSource_CreateShortCode_Call) RunAndReturn(run func(ctx context.Context, request services.CreateShortCodeRequest) (*models.ShortCode, error)) *MockRequestRegisterSource_CreateShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// SMTP provides a mock function for the type MockRequestRegisterSource
func (_mock *MockRequestRegisterSource) SMTP(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any) {
	_mock.Called(ctx, message, lang, tos, data)
	return
}

// MockRequestRegisterSource_SMTP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMTP'
type MockRequestRegisterSource_SMTP_Call struct {
	*mock.Call
}

// SMTP is a helper method to define mock.On call
//   - ctx
//   - message
//   - lang
//   - tos
//   - data
func (_e *MockRequestRegisterSource_Expecter) SMTP(ctx interface{}, message interface{}, lang interface{}, tos interface{}, data interface{}) *MockRequestRegisterSource_SMTP_Call {
	return &MockRequestRegisterSource_SMTP_Call{Call: _e.mock.On("SMTP", ctx, message, lang, tos, data)}
}

func (_c *MockRequestRegisterSource_SMTP_Call) Run(run func(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any)) *MockRequestRegisterSource_SMTP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*template.Template), args[2].(models.Lang), args[3].([]string), args[4].(any))
	})
	return _c
}

func (_c *MockRequestRegisterSource_SMTP_Call) Return() *MockRequestRegisterSource_SMTP_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockRequestRegisterSource_SMTP_Call) RunAndReturn(run func(ctx context.Context, message *template.Template, lang models.Lang, tos []string, data any)) *MockRequestRegisterSource_SMTP_Call {
	_c.Run(run)
	return _c
}

// NewMockSearchKeysSource creates a new instance of MockSearchKeysSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSearchKeysSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSearchKeysSource {
	mock := &MockSearchKeysSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSearchKeysSource is an autogenerated mock type for the SearchKeysSource type
type MockSearchKeysSource struct {
	mock.Mock
}

type MockSearchKeysSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSearchKeysSource) EXPECT() *MockSearchKeysSource_Expecter {
	return &MockSearchKeysSource_Expecter{mock: &_m.Mock}
}

// SearchKeys provides a mock function for the type MockSearchKeysSource
func (_mock *MockSearchKeysSource) SearchKeys(ctx context.Context, usage models.KeyUsage) ([]*dao.KeyEntity, error) {
	ret := _mock.Called(ctx, usage)

	if len(ret) == 0 {
		panic("no return value specified for SearchKeys")
	}

	var r0 []*dao.KeyEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.KeyUsage) ([]*dao.KeyEntity, error)); ok {
		return returnFunc(ctx, usage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.KeyUsage) []*dao.KeyEntity); ok {
		r0 = returnFunc(ctx, usage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*dao.KeyEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.KeyUsage) error); ok {
		r1 = returnFunc(ctx, usage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSearchKeysSource_SearchKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchKeys'
type MockSearchKeysSource_SearchKeys_Call struct {
	*mock.Call
}

// SearchKeys is a helper method to define mock.On call
//   - ctx
//   - usage
func (_e *MockSearchKeysSource_Expecter) SearchKeys(ctx interface{}, usage interface{}) *MockSearchKeysSource_SearchKeys_Call {
	return &MockSearchKeysSource_SearchKeys_Call{Call: _e.mock.On("SearchKeys", ctx, usage)}
}

func (_c *MockSearchKeysSource_SearchKeys_Call) Run(run func(ctx context.Context, usage models.KeyUsage)) *MockSearchKeysSource_SearchKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(models.KeyUsage))
	})
	return _c
}

func (_c *MockSearchKeysSource_SearchKeys_Call) Return(keyEntitys []*dao.KeyEntity, err error) *MockSearchKeysSource_SearchKeys_Call {
	_c.Call.Return(keyEntitys, err)
	return _c
}

func (_c *MockSearchKeysSource_SearchKeys_Call) RunAndReturn(run func(ctx context.Context, usage models.KeyUsage) ([]*dao.KeyEntity, error)) *MockSearchKeysSource_SearchKeys_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSelectKeySource creates a new instance of MockSelectKeySource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSelectKeySource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSelectKeySource {
	mock := &MockSelectKeySource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSelectKeySource is an autogenerated mock type for the SelectKeySource type
type MockSelectKeySource struct {
	mock.Mock
}

type MockSelectKeySource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSelectKeySource) EXPECT() *MockSelectKeySource_Expecter {
	return &MockSelectKeySource_Expecter{mock: &_m.Mock}
}

// SelectKey provides a mock function for the type MockSelectKeySource
func (_mock *MockSelectKeySource) SelectKey(ctx context.Context, id uuid.UUID) (*dao.KeyEntity, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for SelectKey")
	}

	var r0 *dao.KeyEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*dao.KeyEntity, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *dao.KeyEntity); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.KeyEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSelectKeySource_SelectKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectKey'
type MockSelectKeySource_SelectKey_Call struct {
	*mock.Call
}

// SelectKey is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockSelectKeySource_Expecter) SelectKey(ctx interface{}, id interface{}) *MockSelectKeySource_SelectKey_Call {
	return &MockSelectKeySource_SelectKey_Call{Call: _e.mock.On("SelectKey", ctx, id)}
}

func (_c *MockSelectKeySource_SelectKey_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockSelectKeySource_SelectKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockSelectKeySource_SelectKey_Call) Return(keyEntity *dao.KeyEntity, err error) *MockSelectKeySource_SelectKey_Call {
	_c.Call.Return(keyEntity, err)
	return _c
}

func (_c *MockSelectKeySource_SelectKey_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*dao.KeyEntity, error)) *MockSelectKeySource_SelectKey_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSelectUserSource creates a new instance of MockSelectUserSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSelectUserSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSelectUserSource {
	mock := &MockSelectUserSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSelectUserSource is an autogenerated mock type for the SelectUserSource type
type MockSelectUserSource struct {
	mock.Mock
}

type MockSelectUserSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSelectUserSource) EXPECT() *MockSelectUserSource_Expecter {
	return &MockSelectUserSource_Expecter{mock: &_m.Mock}
}

// SelectCredentials provides a mock function for the type MockSelectUserSource
func (_mock *MockSelectUserSource) SelectCredentials(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for SelectCredentials")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSelectUserSource_SelectCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectCredentials'
type MockSelectUserSource_SelectCredentials_Call struct {
	*mock.Call
}

// SelectCredentials is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockSelectUserSource_Expecter) SelectCredentials(ctx interface{}, id interface{}) *MockSelectUserSource_SelectCredentials_Call {
	return &MockSelectUserSource_SelectCredentials_Call{Call: _e.mock.On("SelectCredentials", ctx, id)}
}

func (_c *MockSelectUserSource_SelectCredentials_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockSelectUserSource_SelectCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockSelectUserSource_SelectCredentials_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockSelectUserSource_SelectCredentials_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockSelectUserSource_SelectCredentials_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error)) *MockSelectUserSource_SelectCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateEmailSource creates a new instance of MockUpdateEmailSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateEmailSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateEmailSource {
	mock := &MockUpdateEmailSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateEmailSource is an autogenerated mock type for the UpdateEmailSource type
type MockUpdateEmailSource struct {
	mock.Mock
}

type MockUpdateEmailSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateEmailSource) EXPECT() *MockUpdateEmailSource_Expecter {
	return &MockUpdateEmailSource_Expecter{mock: &_m.Mock}
}

// ConsumeShortCode provides a mock function for the type MockUpdateEmailSource
func (_mock *MockUpdateEmailSource) ConsumeShortCode(ctx context.Context, request services.ConsumeShortCodeRequest) (*models.ShortCode, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeShortCode")
	}

	var r0 *models.ShortCode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.ConsumeShortCodeRequest) (*models.ShortCode, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.ConsumeShortCodeRequest) *models.ShortCode); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ShortCode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.ConsumeShortCodeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateEmailSource_ConsumeShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumeShortCode'
type MockUpdateEmailSource_ConsumeShortCode_Call struct {
	*mock.Call
}

// ConsumeShortCode is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockUpdateEmailSource_Expecter) ConsumeShortCode(ctx interface{}, request interface{}) *MockUpdateEmailSource_ConsumeShortCode_Call {
	return &MockUpdateEmailSource_ConsumeShortCode_Call{Call: _e.mock.On("ConsumeShortCode", ctx, request)}
}

func (_c *MockUpdateEmailSource_ConsumeShortCode_Call) Run(run func(ctx context.Context, request services.ConsumeShortCodeRequest)) *MockUpdateEmailSource_ConsumeShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.ConsumeShortCodeRequest))
	})
	return _c
}

func (_c *MockUpdateEmailSource_ConsumeShortCode_Call) Return(shortCode *models.ShortCode, err error) *MockUpdateEmailSource_ConsumeShortCode_Call {
	_c.Call.Return(shortCode, err)
	return _c
}

func (_c *MockUpdateEmailSource_ConsumeShortCode_Call) RunAndReturn(run func(ctx context.Context, request services.ConsumeShortCodeRequest) (*models.ShortCode, error)) *MockUpdateEmailSource_ConsumeShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCredentialsEmail provides a mock function for the type MockUpdateEmailSource
func (_mock *MockUpdateEmailSource) UpdateCredentialsEmail(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsEmailData) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, userID, data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCredentialsEmail")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, dao.UpdateCredentialsEmailData) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, userID, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, dao.UpdateCredentialsEmailData) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, userID, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, dao.UpdateCredentialsEmailData) error); ok {
		r1 = returnFunc(ctx, userID, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateEmailSource_UpdateCredentialsEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCredentialsEmail'
type MockUpdateEmailSource_UpdateCredentialsEmail_Call struct {
	*mock.Call
}

// UpdateCredentialsEmail is a helper method to define mock.On call
//   - ctx
//   - userID
//   - data
func (_e *MockUpdateEmailSource_Expecter) UpdateCredentialsEmail(ctx interface{}, userID interface{}, data interface{}) *MockUpdateEmailSource_UpdateCredentialsEmail_Call {
	return &MockUpdateEmailSource_UpdateCredentialsEmail_Call{Call: _e.mock.On("UpdateCredentialsEmail", ctx, userID, data)}
}

func (_c *MockUpdateEmailSource_UpdateCredentialsEmail_Call) Run(run func(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsEmailData)) *MockUpdateEmailSource_UpdateCredentialsEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(dao.UpdateCredentialsEmailData))
	})
	return _c
}

func (_c *MockUpdateEmailSource_UpdateCredentialsEmail_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockUpdateEmailSource_UpdateCredentialsEmail_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockUpdateEmailSource_UpdateCredentialsEmail_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsEmailData) (*dao.CredentialsEntity, error)) *MockUpdateEmailSource_UpdateCredentialsEmail_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdatePasswordSource creates a new instance of MockUpdatePasswordSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdatePasswordSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdatePasswordSource {
	mock := &MockUpdatePasswordSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdatePasswordSource is an autogenerated mock type for the UpdatePasswordSource type
type MockUpdatePasswordSource struct {
	mock.Mock
}

type MockUpdatePasswordSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdatePasswordSource) EXPECT() *MockUpdatePasswordSource_Expecter {
	return &MockUpdatePasswordSource_Expecter{mock: &_m.Mock}
}

// ConsumeShortCode provides a mock function for the type MockUpdatePasswordSource
func (_mock *MockUpdatePasswordSource) ConsumeShortCode(ctx context.Context, request services.ConsumeShortCodeRequest) (*models.ShortCode, error) {
	ret := _mock.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ConsumeShortCode")
	}

	var r0 *models.ShortCode
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.ConsumeShortCodeRequest) (*models.ShortCode, error)); ok {
		return returnFunc(ctx, request)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, services.ConsumeShortCodeRequest) *models.ShortCode); ok {
		r0 = returnFunc(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ShortCode)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, services.ConsumeShortCodeRequest) error); ok {
		r1 = returnFunc(ctx, request)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdatePasswordSource_ConsumeShortCode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsumeShortCode'
type MockUpdatePasswordSource_ConsumeShortCode_Call struct {
	*mock.Call
}

// ConsumeShortCode is a helper method to define mock.On call
//   - ctx
//   - request
func (_e *MockUpdatePasswordSource_Expecter) ConsumeShortCode(ctx interface{}, request interface{}) *MockUpdatePasswordSource_ConsumeShortCode_Call {
	return &MockUpdatePasswordSource_ConsumeShortCode_Call{Call: _e.mock.On("ConsumeShortCode", ctx, request)}
}

func (_c *MockUpdatePasswordSource_ConsumeShortCode_Call) Run(run func(ctx context.Context, request services.ConsumeShortCodeRequest)) *MockUpdatePasswordSource_ConsumeShortCode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(services.ConsumeShortCodeRequest))
	})
	return _c
}

func (_c *MockUpdatePasswordSource_ConsumeShortCode_Call) Return(shortCode *models.ShortCode, err error) *MockUpdatePasswordSource_ConsumeShortCode_Call {
	_c.Call.Return(shortCode, err)
	return _c
}

func (_c *MockUpdatePasswordSource_ConsumeShortCode_Call) RunAndReturn(run func(ctx context.Context, request services.ConsumeShortCodeRequest) (*models.ShortCode, error)) *MockUpdatePasswordSource_ConsumeShortCode_Call {
	_c.Call.Return(run)
	return _c
}

// SelectCredentials provides a mock function for the type MockUpdatePasswordSource
func (_mock *MockUpdatePasswordSource) SelectCredentials(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for SelectCredentials")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdatePasswordSource_SelectCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectCredentials'
type MockUpdatePasswordSource_SelectCredentials_Call struct {
	*mock.Call
}

// SelectCredentials is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockUpdatePasswordSource_Expecter) SelectCredentials(ctx interface{}, id interface{}) *MockUpdatePasswordSource_SelectCredentials_Call {
	return &MockUpdatePasswordSource_SelectCredentials_Call{Call: _e.mock.On("SelectCredentials", ctx, id)}
}

func (_c *MockUpdatePasswordSource_SelectCredentials_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockUpdatePasswordSource_SelectCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockUpdatePasswordSource_SelectCredentials_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockUpdatePasswordSource_SelectCredentials_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockUpdatePasswordSource_SelectCredentials_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error)) *MockUpdatePasswordSource_SelectCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCredentialsPassword provides a mock function for the type MockUpdatePasswordSource
func (_mock *MockUpdatePasswordSource) UpdateCredentialsPassword(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsPasswordData) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, userID, data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCredentialsPassword")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, dao.UpdateCredentialsPasswordData) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, userID, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, dao.UpdateCredentialsPasswordData) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, userID, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, dao.UpdateCredentialsPasswordData) error); ok {
		r1 = returnFunc(ctx, userID, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdatePasswordSource_UpdateCredentialsPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCredentialsPassword'
type MockUpdatePasswordSource_UpdateCredentialsPassword_Call struct {
	*mock.Call
}

// UpdateCredentialsPassword is a helper method to define mock.On call
//   - ctx
//   - userID
//   - data
func (_e *MockUpdatePasswordSource_Expecter) UpdateCredentialsPassword(ctx interface{}, userID interface{}, data interface{}) *MockUpdatePasswordSource_UpdateCredentialsPassword_Call {
	return &MockUpdatePasswordSource_UpdateCredentialsPassword_Call{Call: _e.mock.On("UpdateCredentialsPassword", ctx, userID, data)}
}

func (_c *MockUpdatePasswordSource_UpdateCredentialsPassword_Call) Run(run func(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsPasswordData)) *MockUpdatePasswordSource_UpdateCredentialsPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(dao.UpdateCredentialsPasswordData))
	})
	return _c
}

func (_c *MockUpdatePasswordSource_UpdateCredentialsPassword_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockUpdatePasswordSource_UpdateCredentialsPassword_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockUpdatePasswordSource_UpdateCredentialsPassword_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsPasswordData) (*dao.CredentialsEntity, error)) *MockUpdatePasswordSource_UpdateCredentialsPassword_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUpdateRoleSource creates a new instance of MockUpdateRoleSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUpdateRoleSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUpdateRoleSource {
	mock := &MockUpdateRoleSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUpdateRoleSource is an autogenerated mock type for the UpdateRoleSource type
type MockUpdateRoleSource struct {
	mock.Mock
}

type MockUpdateRoleSource_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUpdateRoleSource) EXPECT() *MockUpdateRoleSource_Expecter {
	return &MockUpdateRoleSource_Expecter{mock: &_m.Mock}
}

// SelectCredentials provides a mock function for the type MockUpdateRoleSource
func (_mock *MockUpdateRoleSource) SelectCredentials(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for SelectCredentials")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateRoleSource_SelectCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectCredentials'
type MockUpdateRoleSource_SelectCredentials_Call struct {
	*mock.Call
}

// SelectCredentials is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockUpdateRoleSource_Expecter) SelectCredentials(ctx interface{}, id interface{}) *MockUpdateRoleSource_SelectCredentials_Call {
	return &MockUpdateRoleSource_SelectCredentials_Call{Call: _e.mock.On("SelectCredentials", ctx, id)}
}

func (_c *MockUpdateRoleSource_SelectCredentials_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockUpdateRoleSource_SelectCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockUpdateRoleSource_SelectCredentials_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockUpdateRoleSource_SelectCredentials_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockUpdateRoleSource_SelectCredentials_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*dao.CredentialsEntity, error)) *MockUpdateRoleSource_SelectCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCredentialsRole provides a mock function for the type MockUpdateRoleSource
func (_mock *MockUpdateRoleSource) UpdateCredentialsRole(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsRoleData) (*dao.CredentialsEntity, error) {
	ret := _mock.Called(ctx, userID, data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCredentialsRole")
	}

	var r0 *dao.CredentialsEntity
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, dao.UpdateCredentialsRoleData) (*dao.CredentialsEntity, error)); ok {
		return returnFunc(ctx, userID, data)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, dao.UpdateCredentialsRoleData) *dao.CredentialsEntity); ok {
		r0 = returnFunc(ctx, userID, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dao.CredentialsEntity)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, dao.UpdateCredentialsRoleData) error); ok {
		r1 = returnFunc(ctx, userID, data)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUpdateRoleSource_UpdateCredentialsRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCredentialsRole'
type MockUpdateRoleSource_UpdateCredentialsRole_Call struct {
	*mock.Call
}

// UpdateCredentialsRole is a helper method to define mock.On call
//   - ctx
//   - userID
//   - data
func (_e *MockUpdateRoleSource_Expecter) UpdateCredentialsRole(ctx interface{}, userID interface{}, data interface{}) *MockUpdateRoleSource_UpdateCredentialsRole_Call {
	return &MockUpdateRoleSource_UpdateCredentialsRole_Call{Call: _e.mock.On("UpdateCredentialsRole", ctx, userID, data)}
}

func (_c *MockUpdateRoleSource_UpdateCredentialsRole_Call) Run(run func(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsRoleData)) *MockUpdateRoleSource_UpdateCredentialsRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(dao.UpdateCredentialsRoleData))
	})
	return _c
}

func (_c *MockUpdateRoleSource_UpdateCredentialsRole_Call) Return(credentialsEntity *dao.CredentialsEntity, err error) *MockUpdateRoleSource_UpdateCredentialsRole_Call {
	_c.Call.Return(credentialsEntity, err)
	return _c
}

func (_c *MockUpdateRoleSource_UpdateCredentialsRole_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, data dao.UpdateCredentialsRoleData) (*dao.CredentialsEntity, error)) *MockUpdateRoleSource_UpdateCredentialsRole_Call {
	_c.Call.Return(run)
	return _c
}
